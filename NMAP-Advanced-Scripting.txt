
Web Application Firewall Detection:-
------------------------------------------------------
				A web application firewall, shortened to WAF, detects and blocks malicious traffic transmitting to and from the web server its protecting. WAFs are most commonly used to help protect websites against SQL injection, file inclusion, and cross-site scripting (XSS) attacks.

A server well-protected by a WAF could mean all potential web-based vulnerabilities are thwarted. Adversely, a server unprotected by any kind of WAF could be disastrous for system's administrators trying to defend against hackers. Our ability to detect web application firewalls on target web servers is crucial as pentesters.

The http-waf-detect script is designed to help us learn the presence of a web application firewall. It will probe the target web server with several requests. First, it'll send a normal web request and record the response from the server. Then, it'll send another request with a payload (malformed URL) and compare the responses. This method of detecting WAFs is far from perfect and may vary based on the type of web server and WAF product.

Command:-
------------------
#nmap -p80,443 --script http-waf-detect --script-args="http-waf-detect.aggro,http-waf-detect.detectBodyChanges" targetWebsite.com


#-----------------------------------------------------######-----------------------------------------------------------#


Web Application Firewall Fingerprint Detection:-
----------------------------------------------------------------------
The http-waf-fingerprint Nmap script is designed to help us learn the exact web application firewall in use on a target web server. It will also attempt to identify its type and exact version number.

Command:-
------------------
#nmap -p80,443 --script http-waf-fingerprint targetWebsite.com


We can further improve Nmap's ability to detect WAF types and versions using the http-waf-fingerprint.intensive argument. This will prolong the scan time and also increase the amount of noise (web traffic) generated by the script.

Command:-
------------------
#nmap -p80,443 --script http-waf-fingerprint --script-args http-waf-fingerprint.intensive=1 targetWebsite


#-----------------------------------------------------######-----------------------------------------------------------#


Find HTTP Errors:-
---------------------------
Hypertext Transfer Protocol (HTTP) status codes, also known as "response codes," are issued by web servers to our web browsers when we make requests. These codes are a way for web servers to communicate errors to server administrators, web developers, and end-users alike.

HTTP status codes are split into several categories or "classes." The first digit defines the categories and the following digits are sub-categories, specific to different types of error messages. For example, the 4xx categories is a class of errors specific to HTTP requests that cannot be fulfilled by the web server. Like trying to view a webpage that doesn't exist. That's defined as a status "404 Not Found," probably one of the most well-known status codes on the internet.

Status codes are especially useful to pentester's because it helps us identify broken, malformed, and misconfigured parts of a server which might be leaking sensitive information, or they can allow for some exploitable way of controlling aspects of the server.

1xx (Informational): The request was received, continuing process
2xx (Successful): The request was successfully received, understood, and accepted
3xx (Redirection): Further action needs to be taken in order to complete the request
4xx (Client Error): The request contains bad syntax or cannot be fulfilled
5xx (Server Error): The server failed to fulfill an apparently valid request

Command:-
------------------
#nmap -p80,443 --script http-errors targetWebsite.com


we can use arguments like httpspider.url, httpspider.maxpagecount, and httpspider.maxdepth to refine our scan to specific URLs and define how many pages we want Nmap to crawl before stopping.

Command:-
------------------
#nmap -vv -p80,443 --script http-errors --script-args "httpspider.url=/docs/,httpspider.maxpagecount=3,httpspider.maxdepth=1" targetwebsite.com


#-----------------------------------------------------######-----------------------------------------------------------#


Find Shared & New Servers:-
------------------------------------------
Subdomains are often used to host additional websites for a specific subset of users. For example, Null Byte (null-byte.wonderhowto.com) is one of many subdomains in the WonderHowTo network of websites. Popular subdomains include m.facebook.com, mobile.twitter.com, and developer.github.com.

These subdomains are useful to hackers because the subdomain and main domain may actually be hosted on completely different virtual private servers, in different parts of the world, and may not exercise the same degree of security.

The dns-brute script built into Nmap is designed to enumerate subdomains and their corresponding server IP addresses.

Command:-
------------------
#nmap -p80,443 --script dns-brute targetWebsite.com


Dns-brute will scan using five concurrent threads. We can increase or decrease this value with the dns-brute.threads. Depending on the type of web server, many threads will crash a server or act as a denial of service, making the website slow or unresponsive for other users. Adjust this value with caution.

Dns-brute will attempt about 125 popular subdomains. We can use custom subdomain lists with the dns-brute.hostlist argument. As we can see in the above output, using a comprehensive wordlist, we were able to detect more subdomains and IP addresses controlled by this website.

Command:-
------------------
#nmap -p80,443 --script dns-brute --script-args dns-brute.threads=25,dns-brute.hostlist=/root/Desktop/custom-subdomain-wordlist.txt targetWebsite.com


#-----------------------------------------------------######-----------------------------------------------------------#


Extract EXIF Data from Photos:-
----------------------------------------------
Exchangeable image file, known more as EXIF, is information stored in JPEG, PNG, PDF, and many more file types. This embedded data can sometimes reveal interesting information, including timestamps, device information, and GPS coordinates. Most websites still do not properly sanitize EXIF data from images, leaving themselves or their users at risk.

As penetration testers, knowing what kind of device a target is using will aid us in determining what kind(s) of payloads to generate. A classic example of EXIF data being used to catch a black hat is the arrest of Higinio Ochoa. FBI agents extrapolated his girlfriend's geographic location using the GPS data found in a photo Higinio uploaded to the internet.

Nmap's http-exif-spider script can be used to extract interesting EXIF data from photos found on websites. Such a script isn't useful against mainstream sites like Instagram, Twitter, and Facebook. Major websites scrub EXIF data when users upload new photos. However, personal blogs, small businesses, and corporate organizations may not practice strong security precautions or monitor what employees are posting online. It's not uncommon to find GPS data in photos.

Command:-
------------------
#nmap -p80,443 --script http-exif-spider targetWebsite.com


Use the http.max-cache-size argument and increase the value as needed.

Command:-
------------------
#nmap -p80,443 --script http-exif-spider --script-args="http.max-cache-size=99999999" targetWebsite.com


